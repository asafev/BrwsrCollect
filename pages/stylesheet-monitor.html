<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stylesheet Monitor - AI Agent Detection Framework</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        .stylesheet-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--secondary-color);
        }
        
        .stylesheet-card.injected {
            border-left-color: var(--accent-color);
            background: #fdf2f2;
        }
        
        .stylesheet-card.modified {
            border-left-color: var(--warning-color);
            background: #fff8e1;
        }
        
        .rule-viewer {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .css-diff {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .css-before,
        .css-after {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .css-before {
            border-left: 4px solid var(--success-color);
        }
        
        .css-after {
            border-left: 4px solid var(--accent-color);
        }
        
        .css-property {
            margin: 5px 0;
            padding: 5px 10px;
            background: white;
            border-radius: 4px;
        }
        
        .css-property.suspicious {
            background: #fdf2f2;
            border-left: 3px solid var(--accent-color);
        }
        
        .stylesheet-source {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 10px;
            word-break: break-all;
        }
        
        .injection-alert {
            background: linear-gradient(135deg, #ff6b6b, #ffd93d);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        .real-time-css {
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            margin: 20px 0;
        }
        
        .css-timeline {
            position: relative;
            padding: 20px 0;
        }
        
        .timeline-item {
            position: relative;
            padding: 15px 0 15px 40px;
            border-left: 2px solid #dee2e6;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 20px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--secondary-color);
        }
        
        .timeline-item.injected::before {
            background: var(--accent-color);
        }
        
        .timeline-item.modified::before {
            background: var(--warning-color);
        }
        
        .css-analyzer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="logo">üé® Stylesheet Monitor</div>
            <div>
                <span class="status" id="monitor-status">Inactive</span>
            </div>
        </div>
    </header>

    <nav>
        <div class="nav-container">
            <ul class="nav-menu">
                <li class="nav-item"><a href="../index.html" class="nav-link">Dashboard</a></li>
                <li class="nav-item"><a href="dom-monitor.html" class="nav-link">DOM Monitor</a></li>
                <li class="nav-item"><a href="extension-detector.html" class="nav-link">Extensions</a></li>
                <li class="nav-item"><a href="stylesheet-monitor.html" class="nav-link active">Stylesheets</a></li>
                <li class="nav-item"><a href="overlay-detector.html" class="nav-link">Overlays</a></li>
                <li class="nav-item"><a href="live-dashboard.html" class="nav-link">Live Dashboard</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">üé® CSS & Stylesheet Monitor</h2>
                <p class="card-subtitle">Track stylesheet injections and CSS modifications that may indicate AI agent activity</p>
            </div>
            
            <div class="scan-controls">
                <button id="start-monitoring" class="btn btn-success">Start Monitoring</button>
                <button id="stop-monitoring" class="btn btn-danger">Stop Monitoring</button>
                <button id="scan-current" class="btn btn-primary">Scan Current Styles</button>
                <button id="baseline-snapshot" class="btn btn-secondary">Take Baseline</button>
                <button id="export-styles" class="btn btn-warning">Export Analysis</button>
                <label>
                    <input type="checkbox" id="auto-detect" checked> Auto-detect injections
                </label>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="total-stylesheets">0</div>
                <div class="stat-label">Total Stylesheets</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="injected-styles">0</div>
                <div class="stat-label">Injected Styles</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="suspicious-rules">0</div>
                <div class="stat-label">Suspicious Rules</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="style-changes">0</div>
                <div class="stat-label">Style Changes</div>
            </div>
        </div>

        <div id="injection-alert" class="injection-alert" style="display: none;">
            <h3>üö® Stylesheet Injection Detected!</h3>
            <p>New stylesheets or CSS rules have been injected into the page. This may indicate AI agent activity.</p>
            <button id="analyze-injection" class="btn btn-primary">Analyze Injection</button>
        </div>

        <div class="grid grid-2">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">üìä Real-time CSS Monitor</h3>
                    <p class="card-subtitle">Live feed of stylesheet changes</p>
                </div>
                <div class="real-time-css" id="css-feed">
                    <div>[INIT] CSS Monitor initialized</div>
                    <div>[INFO] Monitoring for stylesheet changes...</div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">üîç Suspicious CSS Rules</h3>
                    <p class="card-subtitle">CSS properties that may indicate automation</p>
                </div>
                <div id="suspicious-css">
                    <div class="css-property">
                        <strong>No suspicious CSS detected</strong>
                        <div>Monitor will highlight potentially malicious CSS rules</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h3 class="card-title">üìã Detected Stylesheets</h3>
                <p class="card-subtitle">All stylesheets currently active on the page</p>
            </div>
            <div id="stylesheet-list">
                <div class="stylesheet-card">
                    <h4>System Ready</h4>
                    <p>Click "Scan Current Styles" to analyze existing stylesheets</p>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h3 class="card-title">‚è±Ô∏è CSS Timeline</h3>
                <p class="card-subtitle">Chronological view of stylesheet changes</p>
            </div>
            <div class="css-timeline" id="css-timeline">
                <div class="timeline-item">
                    <strong>System Initialized</strong>
                    <div class="stylesheet-source">CSS monitoring system ready</div>
                </div>
            </div>
        </div>

        <div class="css-analyzer">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">üî¨ CSS Rule Analyzer</h3>
                    <p class="card-subtitle">Analyze individual CSS rules for suspicious patterns</p>
                </div>
                <div>
                    <input type="text" id="css-selector" placeholder="Enter CSS selector (e.g., .my-class)" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px;">
                    <button id="analyze-selector" class="btn btn-primary">Analyze Selector</button>
                </div>
                <div class="rule-viewer" id="rule-analysis">
                    Enter a CSS selector above to analyze its computed styles
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">üß™ Test CSS Injection</h3>
                    <p class="card-subtitle">Simulate various CSS injection scenarios</p>
                </div>
                <div class="scan-controls">
                    <button id="test-inject-style" class="btn btn-warning">Test: Style Injection</button>
                    <button id="test-modify-existing" class="btn btn-warning">Test: Modify Existing</button>
                    <button id="test-overlay-css" class="btn btn-warning">Test: Overlay CSS</button>
                    <button id="test-hide-elements" class="btn btn-warning">Test: Hide Elements</button>
                </div>
            </div>
        </div>
    </div>

    <script src="../js/ai-detector.js"></script>
    <script>
        let monitoringActive = false;
        let baselineStylesheets = [];
        let currentStylesheets = [];
        let injectedStyles = [];
        let styleChanges = [];
        let suspiciousRules = [];
        let observer = null;

        // Suspicious CSS patterns that may indicate AI agent activity
        const SUSPICIOUS_CSS_PATTERNS = [
            'position: fixed',
            'position: absolute',
            'z-index: 999',
            'opacity: 0',
            'visibility: hidden',
            'pointer-events: none',
            'transform: translate',
            'backdrop-filter',
            'filter: blur',
            'user-select: none',
            'overflow: hidden',
            'cursor: none'
        ];

        const OVERLAY_INDICATORS = [
            'width: 100%',
            'height: 100%',
            'top: 0',
            'left: 0',
            'right: 0',
            'bottom: 0'
        ];

        // Initialize stylesheet monitor
        function initializeStylesheetMonitor() {
            setupEventListeners();
            takeBaselineSnapshot();
            updateStats();
            logToCSS('Stylesheet monitor initialized', 'info');
        }

        function setupEventListeners() {
            document.getElementById('start-monitoring').addEventListener('click', startMonitoring);
            document.getElementById('stop-monitoring').addEventListener('click', stopMonitoring);
            document.getElementById('scan-current').addEventListener('click', scanCurrentStyles);
            document.getElementById('baseline-snapshot').addEventListener('click', takeBaselineSnapshot);
            document.getElementById('export-styles').addEventListener('click', exportStyleAnalysis);
            document.getElementById('analyze-selector').addEventListener('click', analyzeCSSSelector);
            document.getElementById('analyze-injection').addEventListener('click', analyzeLatestInjection);

            // Test buttons
            document.getElementById('test-inject-style').addEventListener('click', testStyleInjection);
            document.getElementById('test-modify-existing').addEventListener('click', testModifyExisting);
            document.getElementById('test-overlay-css').addEventListener('click', testOverlayCSS);
            document.getElementById('test-hide-elements').addEventListener('click', testHideElements);
        }

        function startMonitoring() {
            if (monitoringActive) return;

            monitoringActive = true;
            updateMonitorStatus();
            setupStylesheetObserver();
            logToCSS('CSS monitoring started', 'success');
        }

        function stopMonitoring() {
            if (!monitoringActive) return;

            monitoringActive = false;
            if (observer) {
                observer.disconnect();
                observer = null;
            }
            updateMonitorStatus();
            logToCSS('CSS monitoring stopped', 'warning');
        }

        function setupStylesheetObserver() {
            // Monitor for new style elements and link elements
            observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                if (node.tagName === 'STYLE' || 
                                    (node.tagName === 'LINK' && node.rel === 'stylesheet')) {
                                    handleStylesheetInjection(node);
                                }
                            }
                        });
                    } else if (mutation.type === 'attributes') {
                        if (mutation.attributeName === 'style') {
                            handleInlineStyleChange(mutation.target, mutation.oldValue);
                        }
                    }
                });
            });

            observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeOldValue: true,
                attributeFilter: ['style']
            });

            // Also monitor for changes in existing stylesheets
            monitorExistingStylesheets();
        }

        function handleStylesheetInjection(styleElement) {
            const injection = {
                type: styleElement.tagName === 'STYLE' ? 'inline' : 'external',
                element: styleElement,
                content: styleElement.textContent || '',
                href: styleElement.href || '',
                timestamp: new Date(),
                suspicious: false,
                suspiciousReasons: []
            };

            // Analyze for suspicious patterns
            analyzeStylesheetSuspicion(injection);
            
            injectedStyles.push(injection);
            updateStats();
            
            logToCSS(`New ${injection.type} stylesheet detected: ${injection.href || 'inline'}`, 
                     injection.suspicious ? 'danger' : 'warning');
            
            if (injection.suspicious) {
                showInjectionAlert();
                addSuspiciousCSS(injection);
            }
            
            addToTimeline(injection);
            updateStylesheetList();
        }

        function handleInlineStyleChange(element, oldValue) {
            const newValue = element.getAttribute('style') || '';
            
            if (oldValue !== newValue) {
                const change = {
                    element: element,
                    oldValue: oldValue,
                    newValue: newValue,
                    timestamp: new Date(),
                    suspicious: false,
                    suspiciousReasons: []
                };

                // Analyze for suspicious patterns
                analyzeStyleChangeSuspicion(change);
                
                styleChanges.push(change);
                updateStats();
                
                logToCSS(`Style change detected on ${element.tagName}`, 
                         change.suspicious ? 'danger' : 'info');
                
                if (change.suspicious) {
                    addSuspiciousCSS(change);
                }
                
                addChangeToTimeline(change);
            }
        }

        function analyzeStylesheetSuspicion(injection) {
            const content = injection.content.toLowerCase();
            
            // Check for suspicious CSS patterns
            SUSPICIOUS_CSS_PATTERNS.forEach(pattern => {
                if (content.includes(pattern.toLowerCase())) {
                    injection.suspicious = true;
                    injection.suspiciousReasons.push(`Contains: ${pattern}`);
                }
            });

            // Check for overlay patterns
            let overlayIndicators = 0;
            OVERLAY_INDICATORS.forEach(indicator => {
                if (content.includes(indicator.toLowerCase())) {
                    overlayIndicators++;
                }
            });

            if (overlayIndicators >= 3) {
                injection.suspicious = true;
                injection.suspiciousReasons.push('Overlay pattern detected');
            }

            // Check for AI agent specific patterns
            const aiAgentPatterns = [
                'pplx-agent',
                'comet-agent',
                'ai-assistant',
                'stop-button',
                'agent-overlay'
            ];

            aiAgentPatterns.forEach(pattern => {
                if (content.includes(pattern)) {
                    injection.suspicious = true;
                    injection.suspiciousReasons.push(`AI agent pattern: ${pattern}`);
                }
            });

            // Check for high z-index values
            const zIndexMatch = content.match(/z-index:\s*(\d+)/);
            if (zIndexMatch && parseInt(zIndexMatch[1]) > 9999) {
                injection.suspicious = true;
                injection.suspiciousReasons.push(`High z-index: ${zIndexMatch[1]}`);
            }
        }

        function analyzeStyleChangeSuspicion(change) {
            const newStyle = change.newValue.toLowerCase();
            
            // Check for suspicious inline style changes
            SUSPICIOUS_CSS_PATTERNS.forEach(pattern => {
                if (newStyle.includes(pattern.toLowerCase())) {
                    change.suspicious = true;
                    change.suspiciousReasons.push(`Inline style: ${pattern}`);
                }
            });

            // Check for sudden visibility changes
            if (newStyle.includes('display: none') || newStyle.includes('visibility: hidden')) {
                if (!change.oldValue || !change.oldValue.toLowerCase().includes('display: none')) {
                    change.suspicious = true;
                    change.suspiciousReasons.push('Element hidden');
                }
            }

            // Check for positioning changes that might indicate overlay injection
            if (newStyle.includes('position: fixed') || newStyle.includes('position: absolute')) {
                change.suspicious = true;
                change.suspiciousReasons.push('Positioning change detected');
            }
        }

        function takeBaselineSnapshot() {
            baselineStylesheets = Array.from(document.styleSheets).map(sheet => ({
                href: sheet.href,
                rules: getStyleSheetRules(sheet),
                timestamp: new Date()
            }));
            
            logToCSS(`Baseline snapshot taken: ${baselineStylesheets.length} stylesheets`, 'success');
        }

        function scanCurrentStyles() {
            currentStylesheets = [];
            suspiciousRules = [];
            
            Array.from(document.styleSheets).forEach((sheet, index) => {
                const stylesheetInfo = {
                    index: index,
                    href: sheet.href || 'inline',
                    type: sheet.href ? 'external' : 'inline',
                    rules: getStyleSheetRules(sheet),
                    suspicious: false,
                    suspiciousRules: []
                };

                // Analyze rules for suspicious patterns
                stylesheetInfo.rules.forEach(rule => {
                    if (isSuspiciousRule(rule)) {
                        stylesheetInfo.suspicious = true;
                        stylesheetInfo.suspiciousRules.push(rule);
                        suspiciousRules.push({
                            rule: rule,
                            stylesheet: stylesheetInfo.href,
                            reason: getSuspiciousReason(rule)
                        });
                    }
                });

                currentStylesheets.push(stylesheetInfo);
            });

            updateStats();
            updateStylesheetList();
            updateSuspiciousCSS();
            logToCSS(`Current styles scanned: ${currentStylesheets.length} stylesheets`, 'info');
        }

        function getStyleSheetRules(sheet) {
            try {
                return Array.from(sheet.cssRules || sheet.rules || []).map(rule => rule.cssText);
            } catch (e) {
                // Cross-origin stylesheet or other access issue
                return ['[Cross-origin stylesheet - cannot access rules]'];
            }
        }

        function isSuspiciousRule(ruleText) {
            const rule = ruleText.toLowerCase();
            
            // Check for suspicious patterns
            return SUSPICIOUS_CSS_PATTERNS.some(pattern => 
                rule.includes(pattern.toLowerCase())
            ) || rule.includes('z-index') && /z-index:\s*[1-9]\d{3,}/.test(rule);
        }

        function getSuspiciousReason(ruleText) {
            const rule = ruleText.toLowerCase();
            const reasons = [];
            
            SUSPICIOUS_CSS_PATTERNS.forEach(pattern => {
                if (rule.includes(pattern.toLowerCase())) {
                    reasons.push(pattern);
                }
            });

            if (rule.includes('z-index')) {
                const match = rule.match(/z-index:\s*(\d+)/);
                if (match && parseInt(match[1]) > 9999) {
                    reasons.push(`High z-index: ${match[1]}`);
                }
            }

            return reasons.join(', ');
        }

        function updateStats() {
            document.getElementById('total-stylesheets').textContent = 
                currentStylesheets.length || document.styleSheets.length;
            document.getElementById('injected-styles').textContent = injectedStyles.length;
            document.getElementById('suspicious-rules').textContent = suspiciousRules.length;
            document.getElementById('style-changes').textContent = styleChanges.length;
        }

        function updateMonitorStatus() {
            const statusElement = document.getElementById('monitor-status');
            if (monitoringActive) {
                statusElement.textContent = 'Active';
                statusElement.className = 'status safe';
            } else {
                statusElement.textContent = 'Inactive';
                statusElement.className = 'status';
            }
        }

        function logToCSS(message, level = 'info') {
            const feed = document.getElementById('css-feed');
            const timestamp = new Date().toLocaleTimeString();
            const levelPrefix = level === 'danger' ? '[ALERT]' : level === 'warning' ? '[WARN]' : level === 'success' ? '[OK]' : '[INFO]';
            
            const line = document.createElement('div');
            line.style.color = level === 'danger' ? '#ff6b6b' : level === 'warning' ? '#ffd93d' : level === 'success' ? '#6bcf7f' : '#00ff00';
            line.textContent = `[${timestamp}] ${levelPrefix} ${message}`;
            
            feed.appendChild(line);
            feed.scrollTop = feed.scrollHeight;

            // Keep only last 50 lines
            while (feed.children.length > 50) {
                feed.removeChild(feed.firstChild);
            }
        }

        function showInjectionAlert() {
            const alert = document.getElementById('injection-alert');
            alert.style.display = 'block';
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                alert.style.display = 'none';
            }, 10000);
        }

        function addSuspiciousCSS(item) {
            const container = document.getElementById('suspicious-css');
            
            // Remove "no suspicious" message if present
            if (container.children.length === 1 && container.firstElementChild.textContent.includes('No suspicious')) {
                container.innerHTML = '';
            }

            const cssProperty = document.createElement('div');
            cssProperty.className = 'css-property suspicious';
            
            if (item.type) {
                // Stylesheet injection
                cssProperty.innerHTML = `
                    <strong>${item.type} stylesheet injection</strong>
                    <div>Reasons: ${item.suspiciousReasons.join(', ')}</div>
                    <div class="stylesheet-source">Source: ${item.href || 'inline'}</div>
                `;
            } else {
                // Style change
                cssProperty.innerHTML = `
                    <strong>Inline style change</strong>
                    <div>Reasons: ${item.suspiciousReasons.join(', ')}</div>
                    <div class="stylesheet-source">Element: ${item.element.tagName}</div>
                `;
            }

            container.appendChild(cssProperty);

            // Keep only last 10 items
            while (container.children.length > 10) {
                container.removeChild(container.firstChild);
            }
        }

        function updateStylesheetList() {
            const container = document.getElementById('stylesheet-list');
            container.innerHTML = '';

            if (currentStylesheets.length === 0) {
                container.innerHTML = `
                    <div class="stylesheet-card">
                        <h4>No stylesheets analyzed yet</h4>
                        <p>Click "Scan Current Styles" to analyze existing stylesheets</p>
                    </div>
                `;
                return;
            }

            currentStylesheets.forEach(sheet => {
                const card = document.createElement('div');
                card.className = `stylesheet-card ${sheet.suspicious ? 'injected' : ''}`;
                
                card.innerHTML = `
                    <h4>${sheet.type === 'external' ? 'üîó' : 'üìù'} ${sheet.href}</h4>
                    <div class="stylesheet-source">
                        Type: ${sheet.type} | Rules: ${sheet.rules.length}
                        ${sheet.suspicious ? ` | ‚ö†Ô∏è ${sheet.suspiciousRules.length} suspicious rules` : ''}
                    </div>
                    ${sheet.suspicious ? `
                        <div class="rule-viewer">
                            <strong>Suspicious Rules:</strong><br>
                            ${sheet.suspiciousRules.slice(0, 3).map(rule => 
                                rule.length > 100 ? rule.substring(0, 100) + '...' : rule
                            ).join('<br>')}
                        </div>
                    ` : ''}
                `;

                container.appendChild(card);
            });
        }

        function updateSuspiciousCSS() {
            if (suspiciousRules.length === 0) return;

            const container = document.getElementById('suspicious-css');
            container.innerHTML = '';

            suspiciousRules.forEach(item => {
                const cssProperty = document.createElement('div');
                cssProperty.className = 'css-property suspicious';
                cssProperty.innerHTML = `
                    <strong>Suspicious CSS Rule</strong>
                    <div>Reason: ${item.reason}</div>
                    <div class="stylesheet-source">From: ${item.stylesheet}</div>
                `;
                container.appendChild(cssProperty);
            });
        }

        function addToTimeline(injection) {
            const timeline = document.getElementById('css-timeline');
            const item = document.createElement('div');
            item.className = `timeline-item ${injection.suspicious ? 'injected' : 'modified'}`;
            
            item.innerHTML = `
                <strong>${injection.type} stylesheet ${injection.suspicious ? 'injection (suspicious)' : 'added'}</strong>
                <div>${injection.timestamp.toLocaleTimeString()}</div>
                <div class="stylesheet-source">${injection.href || 'Inline stylesheet'}</div>
                ${injection.suspicious ? `<div>‚ö†Ô∏è ${injection.suspiciousReasons.join(', ')}</div>` : ''}
            `;

            timeline.insertBefore(item, timeline.firstChild);

            // Keep only last 20 items
            while (timeline.children.length > 20) {
                timeline.removeChild(timeline.lastChild);
            }
        }

        function addChangeToTimeline(change) {
            const timeline = document.getElementById('css-timeline');
            const item = document.createElement('div');
            item.className = `timeline-item ${change.suspicious ? 'injected' : 'modified'}`;
            
            item.innerHTML = `
                <strong>Style change ${change.suspicious ? '(suspicious)' : ''}</strong>
                <div>${change.timestamp.toLocaleTimeString()}</div>
                <div class="stylesheet-source">Element: ${change.element.tagName}</div>
                ${change.suspicious ? `<div>‚ö†Ô∏è ${change.suspiciousReasons.join(', ')}</div>` : ''}
            `;

            timeline.insertBefore(item, timeline.firstChild);

            // Keep only last 20 items
            while (timeline.children.length > 20) {
                timeline.removeChild(timeline.lastChild);
            }
        }

        function analyzeCSSSelector() {
            const selector = document.getElementById('css-selector').value.trim();
            const analysisContainer = document.getElementById('rule-analysis');
            
            if (!selector) {
                analysisContainer.textContent = 'Please enter a CSS selector';
                return;
            }

            try {
                const elements = document.querySelectorAll(selector);
                if (elements.length === 0) {
                    analysisContainer.textContent = `No elements found for selector: ${selector}`;
                    return;
                }

                const element = elements[0];
                const computedStyle = window.getComputedStyle(element);
                
                let analysis = `Analysis for selector: ${selector}\n`;
                analysis += `Elements found: ${elements.length}\n\n`;
                analysis += `Computed styles for first element:\n`;
                
                // Check important properties
                const importantProps = [
                    'position', 'z-index', 'opacity', 'visibility', 'display',
                    'width', 'height', 'top', 'left', 'right', 'bottom',
                    'transform', 'pointer-events', 'user-select'
                ];

                importantProps.forEach(prop => {
                    const value = computedStyle.getPropertyValue(prop);
                    if (value && value !== 'auto' && value !== 'none') {
                        analysis += `${prop}: ${value}\n`;
                        
                        // Check if suspicious
                        if (isSuspiciousProperty(prop, value)) {
                            analysis += `  ‚ö†Ô∏è SUSPICIOUS: ${getSuspiciousPropertyReason(prop, value)}\n`;
                        }
                    }
                });

                analysisContainer.textContent = analysis;
            } catch (error) {
                analysisContainer.textContent = `Error analyzing selector: ${error.message}`;
            }
        }

        function isSuspiciousProperty(property, value) {
            const suspiciousChecks = {
                'z-index': (val) => parseInt(val) > 9999,
                'position': (val) => val === 'fixed' || val === 'absolute',
                'opacity': (val) => parseFloat(val) < 0.1,
                'visibility': (val) => val === 'hidden',
                'pointer-events': (val) => val === 'none',
                'user-select': (val) => val === 'none'
            };

            return suspiciousChecks[property] && suspiciousChecks[property](value);
        }

        function getSuspiciousPropertyReason(property, value) {
            const reasons = {
                'z-index': 'Extremely high z-index may indicate overlay',
                'position': 'Absolute/fixed positioning common in overlays',
                'opacity': 'Low opacity may indicate hidden overlay',
                'visibility': 'Hidden elements may be used for tracking',
                'pointer-events': 'Disabled pointer events may indicate overlay',
                'user-select': 'Disabled selection may indicate automation'
            };

            return reasons[property] || 'Potentially suspicious value';
        }

        function monitorExistingStylesheets() {
            // Periodically check for changes in existing stylesheets
            setInterval(() => {
                if (!monitoringActive) return;
                
                const currentCount = document.styleSheets.length;
                const baselineCount = baselineStylesheets.length;
                
                if (currentCount > baselineCount) {
                    logToCSS(`New stylesheets detected: ${currentCount - baselineCount}`, 'warning');
                }
            }, 2000);
        }

        function exportStyleAnalysis() {
            const report = {
                timestamp: new Date().toISOString(),
                baseline: baselineStylesheets,
                current: currentStylesheets,
                injected: injectedStyles,
                changes: styleChanges,
                suspicious: suspiciousRules,
                summary: {
                    totalStylesheets: currentStylesheets.length,
                    injectedStyles: injectedStyles.length,
                    suspiciousRules: suspiciousRules.length,
                    styleChanges: styleChanges.length
                }
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `stylesheet-analysis-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            logToCSS('Analysis exported successfully', 'success');
        }

        function analyzeLatestInjection() {
            if (injectedStyles.length === 0) {
                logToCSS('No injections to analyze', 'warning');
                return;
            }

            const latest = injectedStyles[injectedStyles.length - 1];
            logToCSS(`Analyzing latest injection: ${latest.href || 'inline'}`, 'info');
            
            // Add to timeline and update displays
            addToTimeline(latest);
            if (latest.suspicious) {
                addSuspiciousCSS(latest);
            }
        }

        // Test functions
        function testStyleInjection() {
            const testStyle = document.createElement('style');
            testStyle.textContent = `
                .test-injection-${Date.now()} {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 99999;
                    background: rgba(255, 0, 0, 0.1);
                    pointer-events: none;
                }
            `;
            document.head.appendChild(testStyle);
            
            setTimeout(() => {
                if (testStyle.parentNode) {
                    document.head.removeChild(testStyle);
                }
            }, 3000);
            
            logToCSS('Test: Style injection simulated', 'warning');
        }

        function testModifyExisting() {
            const testElement = document.createElement('div');
            testElement.id = 'test-modify-' + Date.now();
            testElement.style.cssText = 'position: relative; background: blue;';
            document.body.appendChild(testElement);
            
            setTimeout(() => {
                testElement.style.cssText = 'position: fixed; top: 0; left: 0; z-index: 99999; opacity: 0.5;';
                setTimeout(() => {
                    if (testElement.parentNode) {
                        document.body.removeChild(testElement);
                    }
                }, 2000);
            }, 1000);
            
            logToCSS('Test: Style modification simulation', 'warning');
        }

        function testOverlayCSS() {
            const overlayStyle = document.createElement('style');
            overlayStyle.textContent = `
                .pplx-agent-overlay-test {
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100% !important;
                    height: 100% !important;
                    z-index: 999999 !important;
                    background: rgba(0, 0, 0, 0.1) !important;
                    pointer-events: none !important;
                }
            `;
            document.head.appendChild(overlayStyle);
            
            setTimeout(() => {
                if (overlayStyle.parentNode) {
                    document.head.removeChild(overlayStyle);
                }
            }, 4000);
            
            logToCSS('Test: AI agent overlay CSS injected', 'danger');
        }

        function testHideElements() {
            const hideStyle = document.createElement('style');
            hideStyle.textContent = `
                .test-hide-${Date.now()} {
                    visibility: hidden !important;
                    opacity: 0 !important;
                    user-select: none !important;
                }
                body { overflow: hidden !important; }
            `;
            document.head.appendChild(hideStyle);
            
            setTimeout(() => {
                if (hideStyle.parentNode) {
                    document.head.removeChild(hideStyle);
                }
            }, 2000);
            
            logToCSS('Test: Element hiding CSS injected', 'warning');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeStylesheetMonitor);
    </script>
</body>
</html>
